# 자료구조와 알고리즘의 이해
### 자료구조 
#### - 데이터의 표현 및 저장방법
```c
- 선형구조: 데이터를 선의 형태로 나란히 혹은 일렬로 저장하는 방식
ex) 리스트, 스택, 큐
- 비선형구조: 하나의 자료인 Root가 있고 그 아래에 여러개의 원소를 나열시키는 방식
ex) 트리, 그래프
```

### 시간복잡도와 공간복잡도
- 시간복잡도 : 입력의 크기와 문제를 해결하는데 걸리는 시간의 상관관계
- 공간복잡도 : 입력의 크기와 문제를 해결하는데 필요한 공간의 상관관계

### 점근표기법 : 데이터 수의 증가에 따른 연산횟수 증가율의 상한선을 표현한 것
- 최상의 경우: 빅-오메가(Big-Omega) 표기법
```
두 함수 f(n), g(n)이 있을 때, n1 <= n, f(n) >= C * g(n)이 성립하는 상수 C, n1이 존재하면 f(n) = Ω(g(n))이다.
```

- 평균의 경우: 세타 표기법
```
두 함수 f(n), g(n)이 있을 때, f(n) = O(g(n))이면 g(n) = Ω(f(n))이다.
```

- 최악: 빅오표기법
```
두 함수 f(n), g(n)이 있을 때, n1 <= n, f(n) <= C * g(n)이 성립하는 상수 C, n1이 존재하면 f(n) = O(g(n))이다.
```

### 일반적으로 빅오표기법(최악의 경우)을 사용하는 이유
```
어떤 알고리즘이건 '최선의 경우'는 
대개 만족할만한 결과를 보인다.
'평균의 경우'는 평균적인 상황을 알기 위해 
다양한 자료가 필요하며 계산이 복잡해진다. 
'최악의 경우'는 데이터 수가 많아질수록 
연산의 횟수는 알고리즘별로 큰 차이를 보이므로 
성능을 판단하기에 효과적이다.
```

![123](https://user-images.githubusercontent.com/67992469/142136148-ca1c7b26-6d6c-4919-aeec-aa0afc900024.png)

### 빅오표기법 성능
```
O(1) > O(log n) > O( n) > O( n* log n ) > O( n²) > O( n³)  > O( 2n ) > O( n! )
- O(1) : 상수 시간 (데이터 수에 상관X, 연산횟수 고정)
- O(log n) : 로그 시간 (데이터 수 증가율 > 연산횟수 증가율)
- O(n) : 선형 시간 (데이터 수 & 연산횟수 비례)
- O(n* log n) : 로그 선형 시간 (데이터의 수 2배 증가 → 연산횟수 2배 조금 넘게 증가)	
```

### 빅오표기법 특징
```
1. 상수항 무시
2. 영향력 없는 항 무시
```

### 빅오표기법 한계
```
big-O 표기법은 점근적 상한선만 제공하고 점근적으로 근접한 한계를 주지 않는다. 그 예시는 아래와 같다.

10만원을 가지고 있는데, 나는 "1억보다는 적게 있어"라고 말한다면 정확하진 않지만 사실이다.
```

### 코딩테스트에서
컴퓨터는 1초에 대략 3-5억 개 정도의 연산을 처리할 수 있다. 단, 연산이 비트 AND, OR, 비교, 덧셈과 같은 단순한 연산인지,  아니면 나눗셈, 곱셈, 대입, 함수 호출과 같은 복잡한 연산인지에 따라 횟수에 좀 차이가 날 수 있다.

### 시간제한이 1초라면  
### "당신의 프로그램은 3-5억 번의 연산 안에 답을 내고 종료되어야 한다"
```
- 시간복잡도가 N! 일때, N의 값이 12이면 470,000,000. 대략 11까지 돌아가겠구나 생각.
- 시간복잡도가 N^2일때, N의 값이 10000이면 100,000,000. 대략 만까지 돌아가겠구나 생각.
- 시간복잡도가 N^3일때, N의 값이 500이면 125,000,000. 대략 500전까지 돌아가겠구나 생각.
- 시간복잡도가 N^4일때, N의 값이 100이면 100,000,000. 대략 100까지 돌아가겠구나 생각.
- 시간복잡도가 2^N일때, N의 값이 27이면 130,000,000. 대략 27전까지 돌아가겠구나 생각.
- 시간복잡도가 N^2logN일 때, N의 값이 3000이면 대략 12전까지 돌아가겠구나 생각.
- 시간복잡도가 NlogN일 때, N의 값이 5,000,000이면 110,000,000 대략 500만 전까지 돌아가겠구나 생각.
```

### 메모리 제한이 512MB라면 
### int 변수를 대략 1.2억개정도 선언할 수 있다.
```
512MB-> 524,288KB-> 536,870,912B
```

### 순차탐색(Linear Search)
```c
int LSearch(int arr[], int len, int target)
{
    int idx;
    
    idx = -1;
    while (++idx < len)
    {
        if (arr[idx] == target)
            return idx;
    }
    return -1;
```
### 이진탐색(BinarySearch)
```c
int BSearch(int arr[], int len, int target)
{
    int left;
    int right;
    int center;
    
    left = 0;
    right = len - 1;
    while (left <= right)
    {
        center = (left + right) / 2;
        if (arr[center] == target)
            return center;
        else if (arr[center] > target)
            left = center + 1;
        else
            right = center - 1;
    }
    return -1
}
    
